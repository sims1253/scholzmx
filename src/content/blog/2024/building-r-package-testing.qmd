---
title: "Building Robust R Packages: A Testing-First Approach"
description: "How to develop R packages with confidence using test-driven development and modern R tooling."
date: "2024-02-03"
categories: [Programming, R, Software Development]
tags: ["R packages", "testing", "testthat", "TDD", "devtools"]
author: "Maximilian Scholz"
execute:
  echo: true
  eval: true
  warning: false
  message: false
format:
  md:
    variant: gfm
    preserve-yaml: true
---

Building an R package can feel overwhelming, especially when you want to ensure it's robust, maintainable, and user-friendly. After developing several packages and learning from countless mistakes, I've found that starting with testing makes everything else fall into place naturally.

## Why Testing First?

Test-driven development (TDD) isn't just a buzzwordâ€”it's a practical approach that helps you:

1. **Clarify requirements**: Writing tests forces you to think about what your function should actually do
2. **Catch regressions**: Automated tests prevent you from breaking existing functionality
3. **Document behavior**: Tests serve as executable documentation
4. **Improve design**: Testing-first often leads to better API design

## Setting Up Your Testing Infrastructure

Modern R package development relies heavily on the `devtools` ecosystem. Here's my standard setup:

```{r}
#| label: setup-package
#| caption: "Setting up a new R package with testing infrastructure"

# Essential packages for package development
install.packages(c("devtools", "testthat", "roxygen2", "pkgdown"))

# Create new package structure
devtools::create_package("mypackage")

# Set up testing infrastructure
devtools::use_testthat()
devtools::use_package("testthat", type = "Suggests")
```

This gives you a solid foundation with:
- `R/` directory for your functions
- `tests/testthat/` for your tests
- `DESCRIPTION` file properly configured

## The TDD Workflow

Here's my typical workflow when adding a new function:

### 1. Write the Test First

```{r}
#| label: write-tests-first
#| caption: "Writing tests before implementation"

# In tests/testthat/test-color-palette.R
test_that("generate_palette creates correct number of colors", {
  result <- generate_palette(n = 5)
  expect_length(result, 5)
  expect_type(result, "character")
})

test_that("generate_palette handles edge cases", {
  expect_error(generate_palette(n = 0))
  expect_error(generate_palette(n = -1))
  expect_error(generate_palette(n = "not_a_number"))
})
```

### 2. Run the Test (It Should Fail)

```{r}
#| label: run-failing-tests
#| caption: "Running tests to verify they fail initially"

devtools::test()
# Expected: tests fail because function doesn't exist yet
```

### 3. Write Minimal Code to Pass

```{r}
#| label: minimal-implementation
#| caption: "Writing just enough code to make tests pass"

# In R/color-palette.R
#' Generate a color palette
#' 
#' @param n Number of colors to generate
#' @return Character vector of hex colors
#' @export
generate_palette <- function(n) {
  if (!is.numeric(n) || length(n) != 1 || n <= 0) {
    stop("n must be a positive integer")
  }
  
  # Minimal implementation
  rainbow(n)
}
```

### 4. Run Tests Again (They Should Pass)

```{r}
#| label: run-passing-tests
#| caption: "Verifying tests now pass"

devtools::load_all()  # Load your package
devtools::test()      # Run tests
```

### 5. Refactor and Improve

Now that you have working code with tests, you can safely refactor and add features, knowing that your tests will catch any regressions.

## Advanced Testing Patterns

### Testing S3 Methods

```{r}
#| label: s3-method-testing
#| caption: "Testing S3 methods and classes"

# Test S3 method dispatch
test_that("print method works for custom class", {
  obj <- structure(list(data = 1:5), class = "my_class")
  
  expect_output(print(obj), "My Class Object")
  expect_s3_class(obj, "my_class")
})
```

### Testing with Mock Data

```{r}
#| label: mock-data-testing
#| caption: "Using mock data for consistent testing"

# Create helper function for test data
create_test_data <- function() {
  data.frame(
    x = rnorm(100),
    y = rnorm(100),
    group = sample(letters[1:3], 100, replace = TRUE)
  )
}

test_that("analysis function handles different group sizes", {
  test_data <- create_test_data()
  result <- analyze_groups(test_data)
  
  expect_s3_class(result, "data.frame")
  expect_equal(nrow(result), 3)  # one row per group
})
```

### Testing Error Conditions

```{r}
#| label: error-testing
#| caption: "Comprehensive error condition testing"

test_that("function validates inputs properly", {
  # Test various invalid inputs
  expect_error(my_function(NULL), "Input cannot be NULL")
  expect_error(my_function(character(0)), "Input must not be empty")
  expect_error(my_function(c(1, NA)), "Input contains missing values")
  
  # Test that valid inputs don't error
  expect_no_error(my_function(1:10))
})
```

## Continuous Integration

Set up automated testing with GitHub Actions:

```{r}
#| label: github-actions
#| caption: "Setting up CI/CD with GitHub Actions"

# Set up GitHub Actions for R packages
devtools::use_github_action("check-standard")
devtools::use_github_action("test-coverage")
```

## Testing Philosophy

### What to Test

- **Public API**: Every exported function should have tests
- **Edge cases**: Empty inputs, boundary conditions, invalid types
- **Error conditions**: Ensure errors are thrown when expected
- **Integration**: Test how functions work together

### What Not to Test

- **Private functions**: Test through the public API instead
- **Third-party code**: Don't test other packages' functionality
- **Obvious code**: Simple getters/setters often don't need tests

## Practical Tips

1. **Start small**: Begin with basic functionality tests
2. **Test behavior, not implementation**: Focus on what the function should do, not how
3. **Use descriptive test names**: `test_that("returns error for negative input", ...)`
4. **Group related tests**: Use `describe()` blocks for organization
5. **Keep tests fast**: Slow tests discourage frequent running

## Debugging Failed Tests

```{r}
#| label: debugging-tests
#| caption: "Strategies for debugging failing tests"

# Run specific test file
devtools::test_file("tests/testthat/test-my-function.R")

# Debug interactively
debugonce(my_function)
devtools::test_file("tests/testthat/test-my-function.R")

# Check test coverage
covr::package_coverage()
```

## Conclusion

Testing-first development transforms package building from a stressful guessing game into a confident, iterative process. Your tests become a safety net that allows you to refactor fearlessly and add features with confidence.

Remember: perfect is the enemy of good. Start with basic tests and gradually improve. The goal is progress, not perfection.

---

*What testing challenges have you faced in R package development? I'd love to hear about your experiences and solutions.*