{
  "hash": "4e46805cbee4d2421a98424868b800c1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: 'Building bayesim: A DGP to rule them all'\nauthor: \"Maximilian Scholz\"\ndate: \"2023-05-31\"\ncategories: [Development]\ntags: [\"tutorial\", \"R\", \"simulations\", \"testing\"]\ndescription: \"Simulated data is the foundation for any simulation study. In this post I share some thoughts about how I went about supporting arbitrary data generating functions in bayesim.\"\n---\n\n3 figures, two clad in black band t-shirts, the third more formal, stand in \nbetween rows of server racks. The formal figure asks \"So, besides uncapped \njob run time, what do you need?\". The t-shirt warriors pull down their sunglasses,\nshare a sinister look and answer \"Data. Lots of data.\"\n\nThe foundation for any simulation study are data. I guess technically the data don't\nhave to be observations of some data-generating process (DGP) similar to what I have\nbeen using in [bayesim](https://github.com/sims1253/bayesim) so far. They could be\nany kind of artifact you'd like to simulate and do something with afterwards.\nBut in a more general sense, even if you were to run a simulation study on\nimages, sound or functions themselves, each individual instance would represent\none data point.\n\nWriting a data-generating function itself is rather easy, maybe all you need is\na simple `rnorm()` and you are done. The complicated part is to build an interface\nthat supports all the extra wishes we might have in the context of our simulation\nstudy. Maybe we want a training and a testing data set. Maybe some parameters\nof the DGP are randomly drawn during the function call but we need them as reference\nvalues for later when we calculate the estimation bias for the metrics and so on.\nTo allow others to write their own DGPs, I had to define some arguments and an\noutput format that bayesim would expect while just asking the user to hand over\nthe function as simply another argument.\n\nMy solution to this was to write a check function that not only tests a user`s\nfunction but also gives feedback if things are missing and how to fix them.\n\n# Input arguments\n\nBesides the arguments that any data-generating function might need for itself,\nthere are some optional arguments that depend on the kind of metric you might\nwant to calculate on your models later on.\nFollowing along the currently supported metrics in the [metric_lookup](https://github.com/sims1253/bayesim/blob/2d64c950248e8e1eb6f13814b989aa48e2014f27/R/metric_lookup.R#L41) the first thing dependent on the DGP are reference\nvalues for some of the variable base metrics like bias and rmse.\nLuckily we already have the `vars_of_interest` argument that we plan to use during\nmetric calculation that we can simply reuse as we would need reference values for\nall variables of interest anyway.\nFor some of the predictive metrics we need test datasets, that the model hasn't\nseen during fitting. While data generation will be a lot quicker than model\nfitting, I think it is good courtesy not to require additional testing data sets\nwhen they are not needed. A simple `testing_data` flag should be all that we\nneed for this.\nFinally we need to be able to pass an rng `seed` to [make the DGP reproducible](/post/how-to-make-your-simulation-study-reproducible/).\n\nIn R, you can use the `formals()` function to get a list of the *formal arguments*\nof a function. Using this it is rather easy to test if a function accepts the\narguments we just defined:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmissing_dgp_args <- function(fun){\n  required_args <- c(\n    \"vars_of_interest\",\n    \"testing_data\",\n    \"seed\"\n  )\n  return(\n    required_args[\n      !(\n        required_args %in% names(formals(fun))\n      )\n    ]\n  )\n}\n\ngood_dpg <- function(n, vars_of_interest, testing_data, seed) {\n  rep(1, n)\n}\n\nbad_dgp <- function(n, vars_of_interest, testing_data) {\n  rep(1, n)\n}\n\nmissing_dgp_args(good_dpg)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncharacter(0)\n```\n\n\n:::\n\n```{.r .cell-code}\nmissing_dgp_args(bad_dgp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"seed\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}